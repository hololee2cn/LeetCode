# 1124. 表现良好的最长时间段(哈希+前缀和（单调栈）)

```go
package main

import "fmt"

// 1124. 表现良好的最长时间段
// 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。
//
// 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。
//
// 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。
//
// 请你返回「表现良好时间段」的最大长度。
//
//
//
// 示例 1：
//
// 输入：hours = [9,9,6,0,6,6,9]
// 输出：3
// 解释：最长的表现良好时间段是 [9,9,6]。
// 示例 2：
//
// 输入：hours = [6,6,6]
// 输出：0

// 思路:
// 以输入样例 hours = [9,9,6,0,6,6,9] 为例，我们将大于 8 小时的一天记为 1 分，小于等于 8 小时的一天记为 −1 分。那么处理后，我们得到 score = [1, 1, -1, -1, -1, -1, 1]，
// 然后我们对得分数组计算前缀和 presum = [0, 1, 2, 1, 0, -1, -2, -1]。题目要求返回表现良好时间段的最大长度，即求最长的一段中，得分 1 的个数大于得分 −1 的个数，
// 也就是求 score 数组中最长的一段子数组，其和大于 0，那么也就是找出前缀和数组 presum 中两个索引 i 和 j，使 j - i 最大，且保证 presum[j] - presum[i] 大于 0。
// 到此，我们就将这道题转化为，求 presum 数组中的一个最长的上坡，可以用单调栈实现。我们维护一个单调栈，其中存储 presum 中的元素索引，栈中索引指向的元素严格单调递减，
// 由 presum 数组求得单调栈为 stack = [0, 5, 6]， 其表示元素为 [0, -1, -2]。然后我们从后往前遍历 presum 数组，与栈顶索引指向元素比较，如果相减结果大于 0，则一直出栈，
// 直到不大于 0 为止，然后更新当前最大宽度。

func longestWPI(hours []int) int {
	n := len(hours)
	s := 0
	pos := make(map[int]int, 0)
	res := 0
	max := func(v1, v2 int) int {
		if v1 < v2 {
			return v2
		}
		return v1
	}
	for i := 0; i < n; i++ {
		if hours[i] > 8 {
			s++
		} else {
			s--
		}
		if s > 0 {
			res = max(res, i+1)
		}
		if j, ok := pos[s-1]; ok {
			res = max(res, i-j)
		}
		if _, ok := pos[s]; !ok {
			pos[s] = i
		}
	}
	return res
}

func main() {
	cases := [][]int{
		{9, 9, 6, 0, 6, 6, 9},
		{6, 6, 6},
	}
	for _, v := range cases {
		fmt.Println(longestWPI(v))
	}
}
```